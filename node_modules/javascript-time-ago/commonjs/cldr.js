'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.units = undefined;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

exports.default = parse_CLDR;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import { isEqual } from 'lodash'

// The generic time measurement units.
// (other units like "fri" or "thu" are ignored)
// ("quarter" is required by `Intl.RelativeTimeFormat`)
var units = exports.units = ['second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'];

// Detects short and narrow flavours of labels (yr., mo., etc).
// E.g. there are "month", "month-short", "month-narrow".
// More on "narrow" vs "short":
// http://cldr.unicode.org/translation/plurals#TOC-Narrow-and-Short-Forms
var short = /-short$/;
var narrow = /-narrow$/;

// Converts locale data from CLDR format to this library's format.
//
// CLDR locale data example:
//
// ```json
// {
//   "main": {
//     "en-US-POSIX": {
//       "identity": {
//         "language": "en",
//         ...
//       },
//       "dates": {
//         "fields": {
//           "year": {
//             "displayName": "year",
//             "relative-type--1": "last year",
//             "relative-type-0": "this year",
//             "relative-type-1": "next year",
//             "relativeTime-type-future": {
//               "relativeTimePattern-count-one": "in {0} year",
//               "relativeTimePattern-count-other": "in {0} years"
//             },
//             "relativeTime-type-past": {
//               "relativeTimePattern-count-one": "{0} year ago",
//               "relativeTimePattern-count-other": "{0} years ago"
//             }
//           },
// ...
// ```
//
// Parsed locale data example:
//
// ```json
// {
// 	"long":
// 	{
// 		...
// 		"second": [
// 			{
// 				"one": "a second ago",
// 				"other": "{0} seconds ago"
// 			},
// 			{
// 				"one": "in a second",
// 				"other": "in {0} seconds"
// 			}
// 		],
// 		...
// 	},
// 	"short":
// 	{
// 		...
// 	},
// 	...
// }
// ```
function parse_CLDR(data) {
	// Extract `locale` from CLDR data
	var locale = (0, _keys2.default)(data.main)[0];
	var time_units_formatting_rules = data.main[locale].dates.fields;

	return (0, _keys2.default)(time_units_formatting_rules).filter(function (unit) {
		// Take only the generic time measurement units
		// (skip exotic ones like "fri" on "thu").
		return units.indexOf(parse_unit(unit).unit) >= 0;
	}).reduce(function (locale_data, _unit) {
		var _parse_unit = parse_unit(_unit),
		    unit = _parse_unit.unit,
		    type = _parse_unit.type;

		return set_unit_rules(locale_data, type, unit, parse_CLDR_time_unit_formatting_rules(time_units_formatting_rules[_unit]));
	},
	// Parsed locale data
	{});
}

/**
 * Parses CLDR time unit formatting rules.
 * @param  {object} - CLDR time unit formatting rules.
 * @return {(object|string)}
 */
function parse_CLDR_time_unit_formatting_rules(rules_CLDR) {
	var rules = {};

	// "relative" values aren't suitable for "ago" or "in a" cases,
	// because "1 year ago" != "last year" (too vague for Jan 30th)
	// and "in 0.49 years" != "this year" (it could be Nov 30th).
	// Still including them here for `Intl.RelativeTimeFormat` polyfill.

	// "yesterday"
	if (rules_CLDR['relative-type--1']) {
		rules.previous = rules_CLDR['relative-type--1'];
	}

	// "today"
	/* istanbul ignore else */
	if (rules_CLDR['relative-type-0']) {
		rules.current = rules_CLDR['relative-type-0'];
	}

	// "tomorrow"
	if (rules_CLDR['relative-type-1']) {
		rules.next = rules_CLDR['relative-type-1'];
	}

	// Formatting past times.
	//
	// E.g.:
	//
	// "relativeTime-type-past":
	// {
	// 	"relativeTimePattern-count-one": "{0} mo. ago",
	// 	"relativeTimePattern-count-other": "{0} mo. ago"
	// }
	//
	/* istanbul ignore else */
	if (rules_CLDR['relativeTime-type-past']) {
		var past = rules_CLDR['relativeTime-type-past'];
		rules.past = {};

		// Populate all quantifiers ("one", "other", etc).
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(past)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var quantifier = _step.value;

				rules.past[quantifier.replace('relativeTimePattern-count-', '')] = past[quantifier];
			}

			// Delete all duplicates of "other" rule.
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(rules.past)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var _quantifier = _step2.value;

				if (_quantifier !== 'other' && rules.past[_quantifier] === rules.past.other) {
					delete rules.past[_quantifier];
				}
			}

			// If only "other" rule is present then "rules" is not an object and is a string.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		if ((0, _keys2.default)(rules.past).length === 1) {
			rules.past = rules.past.other;
		}
	}

	// Formatting future times.
	//
	// E.g.:
	//
	// "relativeTime-type-future":
	// {
	// 	"relativeTimePattern-count-one": "in {0} mo.",
	// 	"relativeTimePattern-count-other": "in {0} mo."
	// }
	//
	/* istanbul ignore else */
	if (rules_CLDR['relativeTime-type-future']) {
		var future = rules_CLDR['relativeTime-type-future'];
		rules.future = {};

		// Populate all quantifiers ("one", "other", etc).
		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = (0, _getIterator3.default)((0, _keys2.default)(future)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _quantifier2 = _step3.value;

				rules.future[_quantifier2.replace('relativeTimePattern-count-', '')] = future[_quantifier2];
			}

			// Delete all duplicates of "other" rule.
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}

		var _iteratorNormalCompletion4 = true;
		var _didIteratorError4 = false;
		var _iteratorError4 = undefined;

		try {
			for (var _iterator4 = (0, _getIterator3.default)((0, _keys2.default)(rules.future)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
				var _quantifier3 = _step4.value;

				if (_quantifier3 !== 'other' && rules.future[_quantifier3] === rules.future.other) {
					delete rules.future[_quantifier3];
				}
			}

			// If only "other" rule is present then "rules" is not an object and is a string.
		} catch (err) {
			_didIteratorError4 = true;
			_iteratorError4 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion4 && _iterator4.return) {
					_iterator4.return();
				}
			} finally {
				if (_didIteratorError4) {
					throw _iteratorError4;
				}
			}
		}

		if ((0, _keys2.default)(rules.future).length === 1) {
			rules.future = rules.future.other;
		}
	}

	// // If `.past` === `.future` then replace them with `.other`.
	// // (only eligible for "tiny" and "*-time" locale data which is not part of CLDR)
	// if (isEqual(rules.past, rules.future))
	// {
	// 	rules.other = rules.past
	// 	delete rules.future
	// }

	// // If only "other" rule is defined for a time unit
	// // then make "rules" a string rather than an object.
	// if (Object.keys(rules).length === 1)
	// {
	// 	rules = rules.other
	// }

	return rules;
}

/**
 * Sets time unit formatting rules in locale data.
 * @param {object} locale_data
 * @param {string} type
 * @param {string} unit
 * @param {object} rules
 * @return {object} Locale data.
 */
function set_unit_rules(locale_data, type, unit, rules) {
	if (!locale_data[type]) {
		locale_data[type] = {};
	}

	locale_data[type][unit] = rules;

	// Populate "now" unit rules.
	if (unit === 'second' && rules.current) {
		locale_data[type].now = rules.current;
	}

	return locale_data;
}

/**
 * Parses CLDR time unit into `unit` and `type`.
 * @param  {string} CLDR_unit
 * @return {object} `{ type, unit }`.
 */
function parse_unit(unit) {
	if (narrow.test(unit)) {
		return { type: 'narrow', unit: unit.replace(narrow, '') };
	}

	if (short.test(unit)) {
		return { type: 'short', unit: unit.replace(short, '') };
	}

	return { type: 'long', unit: unit };
}
//# sourceMappingURL=cldr.js.map